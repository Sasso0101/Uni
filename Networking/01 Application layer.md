## Application architectures
### Client server architecture
In the client-server architecture there exists an always on host, which usually has a fixed IP address to which all clients connect to obtain resources or to use a service. Clients talk to the server only when they need to, may have dynamically changing IP addresses and are not connected directly to each other.
Pros: easy to implement, clients don't need to be powerful
Cons: single point of failure -> if server goes down, everything goes down, complicated to scale
![[Centralized server.png| 300]]
### Peer to peer architecture
In the peer to peer architecture there is no central node, but all clients act as both servers and clients. In this architecture every connected node is called peer. Peers are intermittently connected and change IP addresses. Some P2P networks have some central nodes that act as directory nodes, which hold information about all peers connected to the network.
A P2P connection is implemented on a host by creating two processes: a client process which communicates with another peer and a server process which waits to be contacted.
Pros: self-scalability (if  clients joins the network in brings with it more capacity)
Cons: difficult to implement
## Sockets
A socket is an interface created by the application and managed by the operating system, through which the application can exchange messages with other processes. To communicate with other processes, it is necessary to know the IP address (network layer) and the port number (transport layer) of the other end. This couple is referred to as socket.
## Application level protocols
The application layer protocols define types of messages exchanged, message syntax, message semantics (meaning of message), rules on when and how processes send and respond to messages. These specifications for open protocols can be found in RFCs to allow for interoperability between different applications.
For an application level protocol to work correctly the underlying layers may need to provide the following functionalities:
- Data integrity: some apps require 100% reliability (ex. file transfer), others not (ex. videoconferencing)
- Timing: some apps require low latency (ex. gaming)
- Throughput: some apps require a minimum amount of throughput (ex. streaming), others are flexible (ex. file transfer)
- Security: encryption, data integrity
### HTTP
A web page consists of objects (HTML files, images, audio...). The HTML contains references to all other objects by means of their URL.
HTTP (Hypertext transfer protocol) is a protocol based on the client server model: the client uses the browser to request and receive objects from the server. The communication is done by using TCP. The client initiates a TCP connection on port 80, which the server then accepts. At the end of the communication then the connection gets closed. HTTP connections can be:
- Non persistent: this means that the connection if closed just after sending one object
- Persistent: multiple objects can be sent on a single TCP connection
RTT (round trip time): time for a small packet to travel from client to server and back
Non persistent HTTP requires 2 RTT per object, because each time a new connection has to be opened. This induces OS overhead, which has to constantly open new connections. Browsers may also decide to open multiple parallel TCP connections. On the other hand with persistent TCP all these problems vanish and we can get as little as 1 RTT per object. HTTP/1.0 used non persistent connections, while HTTP/1.1 uses persistent connections.
There are two types of HTTP messages: request and response.
- Request: contains the request method (GET, PUT, POST...) with the requested page, a header with the host and a body, lines are terminated with \\r\\n
- Response: contains status line (2xx - ok, 3xx - redirect, 4xx - client error, 5xx - server error)
HTTP is stateless, that means that the server maintains no information about past client requests. To simulate state we use cookies, which are small files generated by the server and stored by the client. The client then sends these cookie along with every request to the server.
#### Proxy server
A proxy server is a server between the client and the actual server. When the client asks for a resource the proxy server first checks if it can provide the resource itself, otherwise asks the server for the resource, stores it locally and returns it to the client. Usually proxy servers are installed by ISPs or by companies, universities.
To optimise link utilisation, client can use a conditional GET: specify *If-modified-since* field in header, if file modified after that date send new file, otherwise return just 304 Not Modified
Pros of caching: reduces response time for client request, reduce outgoing traffic
### Electronic mail
In mail exchange there are 3 mail components:
- User agent: writes and reads emails
- Mail server: contains messages to be delivered to the user and queue of messages to send
- Transfer protocol: regulates the transfer of mail between client and server and between servers
#### SMTP protocol
The SMTP protocol is used to reliably transfer email messages by connecting directly the sending server and receiving server. The transfer is made of three parts: handshaking, transfer of messages and closure. Messages are encoded in 7 bit ASCII and there is a command/response interaction (like HTTP). Because multiple commands are sent in the same connection, the connection is persistent.
STMP interaction:
1. Alice sends email using STMP from her user agent to her mail server
2. Alice's mail server goes through the queue of email and using STMP connects to Bobs mail server and sends the email
3. Bob's mail server places the mail in Bob's mailbox, ready to be read
Commands: HELO, MAIL FROM, RCPT TO, DATA. Message is terminated with a dot and a new line.
##### Message format
In the Data field the sender can specify and additional header with the following fields: To, From, Subject. Note that the To field here doesn't actually send the message to those recipients, in is specified purely for the receiver's information.

There have been developed extensions to the standard which allow multimedia messages using MIME encoding. This encoding encodes data in base64.

#### Mail access protocols
While SMTP just deals with exchanging mail between server, there is also the need for a protocol to retrieve the received mail from the server. There have been developed a few of them:
- POP3 (Post Office Protocol): client authenticates itself and asks for mail stored on the server (and possibly deletes them in the process). Protocol is stateless
- IMAP (Internet Mail Access Protocol): keeps the emails on the server and allows the client to organise mail in folders, therefore keeps state between sessions
- HTTP: used by email web clients like GMail, Yahoo...

### Domain Name System (DNS)
The internet gives access to any kind of resource, but it's hard to address these resources. A directory service enables to find resources based on a key-value system (like a phonebook). One implementation of a Distributed Directory Service (DDS) is the Domain Name System (DNS).
DNS allows to retrieve the IP address associated to a domain name. Its structure is hierarchical. DNS offers the following additional services:
- Host aliasing: it is possible to associate some aliases to a domain name (works also for mail), that is, multiple domain names point to the same IP
- Load distribution: DNS can return multiple IP addresses, swapping the order if one gets congested
Pros of a distributed DNS: no single point of failure, traffic gets split among multiple servers, databases can be put closer to user, can be scaled.
Structure of DNS:
1. Root nameservers: 13 logical root nameservers in the world (although many physical copies of them), returns IP address of authoritative nameserver for the requested top-level domain (TLD) server (ex. .com, .edu, .it...)
2. TLD servers: have the addresses of all authoritative name servers of domain names with that TLD
3. Authoritative name servers: name server of the organization, provide DNS resolution for their domains
Each ISP has also its own "local" DNS name server, which provides DNS resolution for their customers. This local DNS server acts like a proxy which caches records and forwards queries into hierarchy if it does not have them cached.
#### DNS querying
When a host wants to resolve a domain name, it asks its local DNS server. If the local DNS server has the response in cache, it passes it directly to the host, otherwise it interrogates the DNS hierarchy. There are two ways of asking: iteratively and recursively. In the iterative approach the DNS servers reply with the address of the next server in the hierarchy, while in the recursive approach the server actually asks the next server for the answer and returns the final answer to the client. Since this method would put a very heavy load on the root nameserver, almost no server supports this method anymore.
![[DNS query.png]]
#### DNS caching
When a nameserver learns about the mapping of an IP address, it stores it in a cache. These entries get deleted after some time (TTL), because they might be outdated.
#### DNS resource records (RR)
DNS servers store resource records (RR) in this format:
```
(name, value, type, ttl)
```
Common values for the type field are:
- A: associates an IPv4 address to a domain name (name: hostname, value: IPv4 address)
- NS: associates an authoritative nameserver to the whole domain (name: domain, value: name of the nameserver)
- CNAME: associates an alias to the canonical name (name: alias hostname, value: real hostname)
- MX: associates the mail server to the domain name (name: domain name, value: domain of the mail server)
#### DNS protocol messages
The DNS protocol specifies two types of messages: request and response. Both have the same format.
![[DNS message.png|300]]
The fields are:
- Identification: 16 bit field which uniquely identifies the answer and the response
- Flag: query/reply, recursion desired, recursion available, reply is authoritative
- Questions: name and type fields for a query
- Answers: requested RRs
- Authority: records for authoritative nameservers
- Additional information which can be useful
#### Inserting new records into DNS
When we register a new domain name at a registrar, the regitrar inserts two RRs into the TLD nameserver: the domain name of the authoritative nameserver and the IP address of the authoritative name server.
Ex.
- (networkutopia.com, dns1.networkutopia.com, NS)
- (dns1.networkutopia.com, 212.212.212.1, A)
## P2P architectures
In a pure P2P architecture there is no central server, but the clients directly communicate with each other intermittently.
### File distribution time
To compute the time required to share a file from a server to all peers in the network we must consider the following factors:
- upload capacity $u_N$ and download capacity $d_N$ of peer N
- upload capacity of server $u_S$
In the case of a tradition client-server configuration the time would be:
```
F = file size
Time to send one copy: F/u_S
Time to send N copies: NF/u_S
Minimum guaranteed client download rate: d_min
Minimum guaranteed client download time: F/d_min
Time to distribute F to N clients: >= max{NF/u_S, NF/d_min}
```
The time increases linearly in N!
![[File distribution.png|300]]
If we use a distributed approach we get:
$F/u_S$ - Time for the server to distribute one copy of the file among the peers
$F/d_{min}$ - Minimum time for one peer to download the whole file (possibly from multiple sources)
Clients in total have to download NF bits -> download is limited by the maximum upload rate $u_S+\sum{u_i}$
$\frac{NF}{(u_S+\sum{u_i})}$ - Total upload capability of the network
Time to distribute F to N clients: $>= max\{\frac{F}{u_S}, \frac{F}{d_{min}}, \frac{NF}{u_S+\sum{u_i}}\}$
Still dependent on N, but when we add new peers we also increase the total bandwidth of the network!
### BitTorrent implementation
When a peer joins the BitTorrent network, it will announce its presence to the tracker server and start collecting chunks from other peers and uploading chucks it already has. The rarest chucks are requested first. The peer will upload chucks only for the 4 peers which are sending to it chunks at the highest rate. Every 30 seconds there is a reevaluation and the peer will optimistically change a peer with a different one.
## Multimedia distribution
The major consumer on internet bandwidth is multimedia. Due to the high volume of traffic and the heterogeneity of the consuming devices, special solutions have to be implemented so that multimedia distribution works at scale.
### DASH protocol
DASH (Dynamic Adaptive Streaming over HTTP) is a protocol which deals with optimising streaming of multimedia over the internet. The server divides the video file into multiple chunks and each chunk is stored in different encodings. Then it produces a manifest file which contains the URLs for the different chunks. The client periodically measures server-to-client bandwidth and, by using the manifest, requests chunks by choosing the most optimal encoding that the network can handle at that point.
### Content Delivery Networks (CDN)
Due to the high volume of traffic that multimedia generates, it is advisable to distribute the same resources across multiple servers. With this approach we are avoiding having a single point of failure, a single point of network congestion and a possibly long distance between users and server. These servers are called CDNs and are strategically placed close to the end users to reduce latency.